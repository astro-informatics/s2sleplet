<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sleplet.utils.harmonic_methods API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sleplet.utils.harmonic_methods</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections.abc import Callable
from typing import Any

import numpy as np
import pyssht as ssht
from numpy import typing as npt
from numpy.random import Generator

from sleplet.meshes.classes.mesh import Mesh
from sleplet.utils.integration_methods import integrate_whole_mesh
from sleplet.utils.vars import (
    AFRICA_ALPHA,
    AFRICA_BETA,
    AFRICA_GAMMA,
    SAMPLING_SCHEME,
    SOUTH_AMERICA_ALPHA,
    SOUTH_AMERICA_BETA,
    SOUTH_AMERICA_GAMMA,
)


def create_spherical_harmonic(L: int, ind: int) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    create a spherical harmonic in harmonic space for the given index
    &#34;&#34;&#34;
    flm = np.zeros(L**2, dtype=np.complex_)
    flm[ind] = 1
    return flm


def boost_coefficient_resolution(flm: npt.NDArray[Any], boost: int) -&gt; npt.NDArray[Any]:
    &#34;&#34;&#34;
    calculates a boost in resolution for given flm
    &#34;&#34;&#34;
    return np.pad(flm, (0, boost), &#34;constant&#34;)


def invert_flm_boosted(
    flm: npt.NDArray[np.complex_],
    L: int,
    resolution: int,
    *,
    reality: bool = False,
    spin: int = 0,
) -&gt; npt.NDArray[np.complex_ | np.float_]:
    &#34;&#34;&#34;
    performs the inverse harmonic transform
    &#34;&#34;&#34;
    boost = resolution**2 - L**2
    flm = boost_coefficient_resolution(flm, boost)
    return ssht.inverse(
        flm, resolution, Reality=reality, Spin=spin, Method=SAMPLING_SCHEME
    )


def ensure_f_bandlimited(
    grid_fun: Callable[
        [npt.NDArray[np.float_], npt.NDArray[np.float_]], npt.NDArray[np.float_]
    ],
    L: int,
    *,
    reality: bool,
    spin: int,
) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    if the function created is created in pixel space rather than harmonic
    space then need to transform it into harmonic space first before using it
    &#34;&#34;&#34;
    thetas, phis = ssht.sample_positions(L, Grid=True, Method=SAMPLING_SCHEME)
    f = grid_fun(thetas, phis)
    return ssht.forward(f, L, Reality=reality, Spin=spin, Method=SAMPLING_SCHEME)


def create_emm_vector(L: int) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    create vector of m values for a given L
    &#34;&#34;&#34;
    emm = np.zeros(2 * L * 2 * L)
    k = 0

    for ell in range(2 * L):
        M = 2 * ell + 1
        emm[k : k + M] = np.arange(-ell, ell + 1)
        k += M
    return emm


def compute_random_signal(
    L: int, rng: Generator, *, var_signal: float
) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    generates a normally distributed random signal of a
    complex signal with mean 0 and variance 1
    &#34;&#34;&#34;
    return np.sqrt(var_signal / 2) * (
        rng.standard_normal(L**2) + 1j * rng.standard_normal(L**2)
    )


def mesh_forward(
    mesh: Mesh, u: npt.NDArray[np.complex_ | np.float_]
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    computes the mesh forward transform from real space to harmonic space
    &#34;&#34;&#34;
    u_i = np.zeros(mesh.mesh_eigenvalues.shape[0])
    for i, phi_i in enumerate(mesh.basis_functions):
        u_i[i] = integrate_whole_mesh(mesh.vertices, mesh.faces, u, phi_i)
    return u_i


def mesh_inverse(
    mesh: Mesh, u_i: npt.NDArray[np.complex_ | np.float_]
) -&gt; npt.NDArray[np.complex_ | np.float_]:
    &#34;&#34;&#34;
    computes the mesh inverse transform from harmonic space to real space
    &#34;&#34;&#34;
    return (u_i[:, np.newaxis] * mesh.basis_functions).sum(axis=0)


def rotate_earth_to_south_america(
    earth_flm: npt.NDArray[np.complex_ | np.float_], L: int
) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    rotates the flms of the Earth to a view centered on South America
    &#34;&#34;&#34;
    return ssht.rotate_flms(
        earth_flm, SOUTH_AMERICA_ALPHA, SOUTH_AMERICA_BETA, SOUTH_AMERICA_GAMMA, L
    )


def rotate_earth_to_africa(
    earth_flm: npt.NDArray[np.complex_ | np.float_], L: int
) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    rotates the flms of the Earth to a view centered on Africa
    &#34;&#34;&#34;
    return ssht.rotate_flms(earth_flm, AFRICA_ALPHA, AFRICA_BETA, AFRICA_GAMMA, L)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sleplet.utils.harmonic_methods.boost_coefficient_resolution"><code class="name flex">
<span>def <span class="ident">boost_coefficient_resolution</span></span>(<span>flm: numpy.ndarray[typing.Any, numpy.dtype[typing.Any]], boost: int) ‑> numpy.ndarray[typing.Any, numpy.dtype[typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>calculates a boost in resolution for given flm</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boost_coefficient_resolution(flm: npt.NDArray[Any], boost: int) -&gt; npt.NDArray[Any]:
    &#34;&#34;&#34;
    calculates a boost in resolution for given flm
    &#34;&#34;&#34;
    return np.pad(flm, (0, boost), &#34;constant&#34;)</code></pre>
</details>
</dd>
<dt id="sleplet.utils.harmonic_methods.compute_random_signal"><code class="name flex">
<span>def <span class="ident">compute_random_signal</span></span>(<span>L: int, rng: numpy.random._generator.Generator, *, var_signal: float) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128]]</span>
</code></dt>
<dd>
<div class="desc"><p>generates a normally distributed random signal of a
complex signal with mean 0 and variance 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_random_signal(
    L: int, rng: Generator, *, var_signal: float
) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    generates a normally distributed random signal of a
    complex signal with mean 0 and variance 1
    &#34;&#34;&#34;
    return np.sqrt(var_signal / 2) * (
        rng.standard_normal(L**2) + 1j * rng.standard_normal(L**2)
    )</code></pre>
</details>
</dd>
<dt id="sleplet.utils.harmonic_methods.create_emm_vector"><code class="name flex">
<span>def <span class="ident">create_emm_vector</span></span>(<span>L: int) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>create vector of m values for a given L</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_emm_vector(L: int) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    create vector of m values for a given L
    &#34;&#34;&#34;
    emm = np.zeros(2 * L * 2 * L)
    k = 0

    for ell in range(2 * L):
        M = 2 * ell + 1
        emm[k : k + M] = np.arange(-ell, ell + 1)
        k += M
    return emm</code></pre>
</details>
</dd>
<dt id="sleplet.utils.harmonic_methods.create_spherical_harmonic"><code class="name flex">
<span>def <span class="ident">create_spherical_harmonic</span></span>(<span>L: int, ind: int) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128]]</span>
</code></dt>
<dd>
<div class="desc"><p>create a spherical harmonic in harmonic space for the given index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_spherical_harmonic(L: int, ind: int) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    create a spherical harmonic in harmonic space for the given index
    &#34;&#34;&#34;
    flm = np.zeros(L**2, dtype=np.complex_)
    flm[ind] = 1
    return flm</code></pre>
</details>
</dd>
<dt id="sleplet.utils.harmonic_methods.ensure_f_bandlimited"><code class="name flex">
<span>def <span class="ident">ensure_f_bandlimited</span></span>(<span>grid_fun: collections.abc.Callable[[numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]], numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]], L: int, *, reality: bool, spin: int) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128]]</span>
</code></dt>
<dd>
<div class="desc"><p>if the function created is created in pixel space rather than harmonic
space then need to transform it into harmonic space first before using it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_f_bandlimited(
    grid_fun: Callable[
        [npt.NDArray[np.float_], npt.NDArray[np.float_]], npt.NDArray[np.float_]
    ],
    L: int,
    *,
    reality: bool,
    spin: int,
) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    if the function created is created in pixel space rather than harmonic
    space then need to transform it into harmonic space first before using it
    &#34;&#34;&#34;
    thetas, phis = ssht.sample_positions(L, Grid=True, Method=SAMPLING_SCHEME)
    f = grid_fun(thetas, phis)
    return ssht.forward(f, L, Reality=reality, Spin=spin, Method=SAMPLING_SCHEME)</code></pre>
</details>
</dd>
<dt id="sleplet.utils.harmonic_methods.invert_flm_boosted"><code class="name flex">
<span>def <span class="ident">invert_flm_boosted</span></span>(<span>flm: numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128]], L: int, resolution: int, *, reality: bool = False, spin: int = 0) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128 | numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>performs the inverse harmonic transform</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert_flm_boosted(
    flm: npt.NDArray[np.complex_],
    L: int,
    resolution: int,
    *,
    reality: bool = False,
    spin: int = 0,
) -&gt; npt.NDArray[np.complex_ | np.float_]:
    &#34;&#34;&#34;
    performs the inverse harmonic transform
    &#34;&#34;&#34;
    boost = resolution**2 - L**2
    flm = boost_coefficient_resolution(flm, boost)
    return ssht.inverse(
        flm, resolution, Reality=reality, Spin=spin, Method=SAMPLING_SCHEME
    )</code></pre>
</details>
</dd>
<dt id="sleplet.utils.harmonic_methods.mesh_forward"><code class="name flex">
<span>def <span class="ident">mesh_forward</span></span>(<span>mesh: <a title="sleplet.meshes.classes.mesh.Mesh" href="../meshes/classes/mesh.html#sleplet.meshes.classes.mesh.Mesh">Mesh</a>, u: numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128 | numpy.float64]]) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>computes the mesh forward transform from real space to harmonic space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mesh_forward(
    mesh: Mesh, u: npt.NDArray[np.complex_ | np.float_]
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    computes the mesh forward transform from real space to harmonic space
    &#34;&#34;&#34;
    u_i = np.zeros(mesh.mesh_eigenvalues.shape[0])
    for i, phi_i in enumerate(mesh.basis_functions):
        u_i[i] = integrate_whole_mesh(mesh.vertices, mesh.faces, u, phi_i)
    return u_i</code></pre>
</details>
</dd>
<dt id="sleplet.utils.harmonic_methods.mesh_inverse"><code class="name flex">
<span>def <span class="ident">mesh_inverse</span></span>(<span>mesh: <a title="sleplet.meshes.classes.mesh.Mesh" href="../meshes/classes/mesh.html#sleplet.meshes.classes.mesh.Mesh">Mesh</a>, u_i: numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128 | numpy.float64]]) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128 | numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>computes the mesh inverse transform from harmonic space to real space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mesh_inverse(
    mesh: Mesh, u_i: npt.NDArray[np.complex_ | np.float_]
) -&gt; npt.NDArray[np.complex_ | np.float_]:
    &#34;&#34;&#34;
    computes the mesh inverse transform from harmonic space to real space
    &#34;&#34;&#34;
    return (u_i[:, np.newaxis] * mesh.basis_functions).sum(axis=0)</code></pre>
</details>
</dd>
<dt id="sleplet.utils.harmonic_methods.rotate_earth_to_africa"><code class="name flex">
<span>def <span class="ident">rotate_earth_to_africa</span></span>(<span>earth_flm: numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128 | numpy.float64]], L: int) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128]]</span>
</code></dt>
<dd>
<div class="desc"><p>rotates the flms of the Earth to a view centered on Africa</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_earth_to_africa(
    earth_flm: npt.NDArray[np.complex_ | np.float_], L: int
) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    rotates the flms of the Earth to a view centered on Africa
    &#34;&#34;&#34;
    return ssht.rotate_flms(earth_flm, AFRICA_ALPHA, AFRICA_BETA, AFRICA_GAMMA, L)</code></pre>
</details>
</dd>
<dt id="sleplet.utils.harmonic_methods.rotate_earth_to_south_america"><code class="name flex">
<span>def <span class="ident">rotate_earth_to_south_america</span></span>(<span>earth_flm: numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128 | numpy.float64]], L: int) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128]]</span>
</code></dt>
<dd>
<div class="desc"><p>rotates the flms of the Earth to a view centered on South America</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_earth_to_south_america(
    earth_flm: npt.NDArray[np.complex_ | np.float_], L: int
) -&gt; npt.NDArray[np.complex_]:
    &#34;&#34;&#34;
    rotates the flms of the Earth to a view centered on South America
    &#34;&#34;&#34;
    return ssht.rotate_flms(
        earth_flm, SOUTH_AMERICA_ALPHA, SOUTH_AMERICA_BETA, SOUTH_AMERICA_GAMMA, L
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sleplet.utils" href="index.html">sleplet.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sleplet.utils.harmonic_methods.boost_coefficient_resolution" href="#sleplet.utils.harmonic_methods.boost_coefficient_resolution">boost_coefficient_resolution</a></code></li>
<li><code><a title="sleplet.utils.harmonic_methods.compute_random_signal" href="#sleplet.utils.harmonic_methods.compute_random_signal">compute_random_signal</a></code></li>
<li><code><a title="sleplet.utils.harmonic_methods.create_emm_vector" href="#sleplet.utils.harmonic_methods.create_emm_vector">create_emm_vector</a></code></li>
<li><code><a title="sleplet.utils.harmonic_methods.create_spherical_harmonic" href="#sleplet.utils.harmonic_methods.create_spherical_harmonic">create_spherical_harmonic</a></code></li>
<li><code><a title="sleplet.utils.harmonic_methods.ensure_f_bandlimited" href="#sleplet.utils.harmonic_methods.ensure_f_bandlimited">ensure_f_bandlimited</a></code></li>
<li><code><a title="sleplet.utils.harmonic_methods.invert_flm_boosted" href="#sleplet.utils.harmonic_methods.invert_flm_boosted">invert_flm_boosted</a></code></li>
<li><code><a title="sleplet.utils.harmonic_methods.mesh_forward" href="#sleplet.utils.harmonic_methods.mesh_forward">mesh_forward</a></code></li>
<li><code><a title="sleplet.utils.harmonic_methods.mesh_inverse" href="#sleplet.utils.harmonic_methods.mesh_inverse">mesh_inverse</a></code></li>
<li><code><a title="sleplet.utils.harmonic_methods.rotate_earth_to_africa" href="#sleplet.utils.harmonic_methods.rotate_earth_to_africa">rotate_earth_to_africa</a></code></li>
<li><code><a title="sleplet.utils.harmonic_methods.rotate_earth_to_south_america" href="#sleplet.utils.harmonic_methods.rotate_earth_to_south_america">rotate_earth_to_south_america</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>