<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sleplet.utils.plot_methods API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sleplet.utils.plot_methods</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pathlib import Path

import numpy as np
import pyssht as ssht
from matplotlib import colors
from matplotlib import pyplot as plt
from numpy import typing as npt

from sleplet import logger
from sleplet.functions.coefficients import Coefficients
from sleplet.utils.config import settings
from sleplet.utils.harmonic_methods import invert_flm_boosted
from sleplet.utils.mask_methods import create_mask_region
from sleplet.utils.region import Region
from sleplet.utils.slepian_methods import slepian_inverse
from sleplet.utils.vars import (
    SAMPLING_SCHEME,
    SPHERE_UNSEEN,
)


def calc_plot_resolution(L: int) -&gt; int:
    &#34;&#34;&#34;
    calculate appropriate resolution for given L
    &#34;&#34;&#34;
    res_dict = {1: 6, 2: 5, 3: 4, 7: 3, 9: 2, 10: 1}

    return next(
        (
            L * 2**exponent
            for log_bandlimit, exponent in res_dict.items()
            if 2**log_bandlimit &gt; L
        ),
        L,
    )


def convert_colourscale(
    cmap: colors, *, pl_entries: int = 255
) -&gt; list[tuple[float, str]]:
    &#34;&#34;&#34;
    converts cmocean colourscale to a plotly colourscale
    &#34;&#34;&#34;
    h = 1 / (pl_entries - 1)
    pl_colorscale = []

    for k in range(pl_entries):
        C = list(map(np.uint8, np.array(cmap(k * h)[:3]) * 255))
        pl_colorscale.append((k * h, f&#34;rgb{(C[0], C[1], C[2])}&#34;))

    return pl_colorscale


def calc_nearest_grid_point(
    L: int, alpha_pi_fraction: float, beta_pi_fraction: float
) -&gt; tuple[float, float]:
    &#34;&#34;&#34;
    calculate nearest index of alpha/beta for translation
    this is due to calculating omega&#39; through the pixel
    values - the translation needs to be at the same position
    as the rotation such that the difference error is small
    &#34;&#34;&#34;
    thetas, phis = ssht.sample_positions(L, Method=SAMPLING_SCHEME)
    pix_j = np.abs(phis - alpha_pi_fraction * np.pi).argmin()
    pix_i = np.abs(thetas - beta_pi_fraction * np.pi).argmin()
    alpha, beta = phis[pix_j], thetas[pix_i]
    logger.info(f&#34;grid point: (alpha, beta)=({alpha:e}, {beta:e})&#34;)
    return alpha, beta


def save_plot(path: Path, name: str) -&gt; None:
    &#34;&#34;&#34;
    helper method to save plots
    &#34;&#34;&#34;
    plt.tight_layout()
    if settings[&#34;SAVE_FIG&#34;]:
        for file_type in {&#34;png&#34;, &#34;pdf&#34;}:
            logger.info(f&#34;saving {file_type}&#34;)
            filename = path / file_type / f&#34;{name}.{file_type}&#34;
            plt.savefig(filename, bbox_inches=&#34;tight&#34;)
    if settings[&#34;AUTO_OPEN&#34;]:
        plt.show()


def find_max_amplitude(
    function: Coefficients, *, plot_type: str = &#34;real&#34;, upsample: bool = True
) -&gt; float:
    &#34;&#34;&#34;
    for a given set of coefficients it finds the largest absolute value for a
    given plot type such that plots can have the same scale as the input
    &#34;&#34;&#34;
    # compute inverse transform
    if hasattr(function, &#34;slepian&#34;):
        field = slepian_inverse(function.coefficients, function.L, function.slepian)
    else:
        field = ssht.inverse(function.coefficients, function.L, Method=SAMPLING_SCHEME)

    # find resolution of final plot for boosting if necessary
    resolution = calc_plot_resolution(function.L) if upsample else function.L

    # boost field to match final plot
    boosted_field = boost_field(
        field,
        function.L,
        resolution,
        reality=function.reality,
        spin=function.spin,
        upsample=upsample,
    )

    # find maximum absolute value for given plot type
    return np.abs(create_plot_type(boosted_field, plot_type)).max()


def create_plot_type(
    field: npt.NDArray[np.complex_ | np.float_], plot_type: str
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    gets the given plot type of the field
    &#34;&#34;&#34;
    logger.info(f&#34;plotting type: &#39;{plot_type}&#39;&#34;)
    plot_dict = {
        &#34;abs&#34;: np.abs(field),
        &#34;imag&#34;: field.imag,
        &#34;real&#34;: field.real,
        &#34;sum&#34;: field.real + field.imag,
    }
    return plot_dict[plot_type]


def set_outside_region_to_minimum(
    f_plot: npt.NDArray[np.float_], L: int, region: Region
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    for the Slepian region set the outisde area to negative infinity
    hence it is clear we are only interested in the coloured region
    &#34;&#34;&#34;
    # create mask of interest
    mask = create_mask_region(L, region)

    # adapt for closed plot
    _, n_phi = ssht.sample_shape(L, Method=SAMPLING_SCHEME)
    closed_mask = np.insert(mask, n_phi, mask[:, 0], axis=1)

    # set values outside mask to negative infinity
    return np.where(closed_mask, f_plot, SPHERE_UNSEEN)


def normalise_function(
    f: npt.NDArray[np.float_], *, normalise: bool
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    normalise function between 0 and 1 for visualisation
    &#34;&#34;&#34;
    if not normalise:
        return f
    elif (f == 0).all():
        # if all 0, set to 0
        return f + 0.5
    elif np.allclose(f, f.max()):
        # if all non-zero, set to 1
        return f / f.max()
    else:
        # scale from [0, 1]
        return (f - f.min()) / f.ptp()


def boost_field(
    field: npt.NDArray[np.complex_ | np.float_],
    L: int,
    resolution: int,
    *,
    reality: bool,
    spin: int,
    upsample: bool,
) -&gt; npt.NDArray[np.complex_ | np.float_]:
    &#34;&#34;&#34;
    inverts and then boosts the field before plotting
    &#34;&#34;&#34;
    if not upsample:
        return field
    flm = ssht.forward(field, L, Reality=reality, Spin=spin, Method=SAMPLING_SCHEME)
    return invert_flm_boosted(flm, L, resolution, reality=reality, spin=spin)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sleplet.utils.plot_methods.boost_field"><code class="name flex">
<span>def <span class="ident">boost_field</span></span>(<span>field: numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128 | numpy.float64]], L: int, resolution: int, *, reality: bool, spin: int, upsample: bool) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128 | numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>inverts and then boosts the field before plotting</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boost_field(
    field: npt.NDArray[np.complex_ | np.float_],
    L: int,
    resolution: int,
    *,
    reality: bool,
    spin: int,
    upsample: bool,
) -&gt; npt.NDArray[np.complex_ | np.float_]:
    &#34;&#34;&#34;
    inverts and then boosts the field before plotting
    &#34;&#34;&#34;
    if not upsample:
        return field
    flm = ssht.forward(field, L, Reality=reality, Spin=spin, Method=SAMPLING_SCHEME)
    return invert_flm_boosted(flm, L, resolution, reality=reality, spin=spin)</code></pre>
</details>
</dd>
<dt id="sleplet.utils.plot_methods.calc_nearest_grid_point"><code class="name flex">
<span>def <span class="ident">calc_nearest_grid_point</span></span>(<span>L: int, alpha_pi_fraction: float, beta_pi_fraction: float) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>calculate nearest index of alpha/beta for translation
this is due to calculating omega' through the pixel
values - the translation needs to be at the same position
as the rotation such that the difference error is small</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_nearest_grid_point(
    L: int, alpha_pi_fraction: float, beta_pi_fraction: float
) -&gt; tuple[float, float]:
    &#34;&#34;&#34;
    calculate nearest index of alpha/beta for translation
    this is due to calculating omega&#39; through the pixel
    values - the translation needs to be at the same position
    as the rotation such that the difference error is small
    &#34;&#34;&#34;
    thetas, phis = ssht.sample_positions(L, Method=SAMPLING_SCHEME)
    pix_j = np.abs(phis - alpha_pi_fraction * np.pi).argmin()
    pix_i = np.abs(thetas - beta_pi_fraction * np.pi).argmin()
    alpha, beta = phis[pix_j], thetas[pix_i]
    logger.info(f&#34;grid point: (alpha, beta)=({alpha:e}, {beta:e})&#34;)
    return alpha, beta</code></pre>
</details>
</dd>
<dt id="sleplet.utils.plot_methods.calc_plot_resolution"><code class="name flex">
<span>def <span class="ident">calc_plot_resolution</span></span>(<span>L: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>calculate appropriate resolution for given L</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_plot_resolution(L: int) -&gt; int:
    &#34;&#34;&#34;
    calculate appropriate resolution for given L
    &#34;&#34;&#34;
    res_dict = {1: 6, 2: 5, 3: 4, 7: 3, 9: 2, 10: 1}

    return next(
        (
            L * 2**exponent
            for log_bandlimit, exponent in res_dict.items()
            if 2**log_bandlimit &gt; L
        ),
        L,
    )</code></pre>
</details>
</dd>
<dt id="sleplet.utils.plot_methods.convert_colourscale"><code class="name flex">
<span>def <span class="ident">convert_colourscale</span></span>(<span>cmap: <module 'matplotlib.colors' from '/opt/hostedtoolcache/Python/3.10.10/x64/lib/python3.10/site-packages/matplotlib/colors.py'>, *, pl_entries: int = 255) ‑> list[tuple[float, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>converts cmocean colourscale to a plotly colourscale</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_colourscale(
    cmap: colors, *, pl_entries: int = 255
) -&gt; list[tuple[float, str]]:
    &#34;&#34;&#34;
    converts cmocean colourscale to a plotly colourscale
    &#34;&#34;&#34;
    h = 1 / (pl_entries - 1)
    pl_colorscale = []

    for k in range(pl_entries):
        C = list(map(np.uint8, np.array(cmap(k * h)[:3]) * 255))
        pl_colorscale.append((k * h, f&#34;rgb{(C[0], C[1], C[2])}&#34;))

    return pl_colorscale</code></pre>
</details>
</dd>
<dt id="sleplet.utils.plot_methods.create_plot_type"><code class="name flex">
<span>def <span class="ident">create_plot_type</span></span>(<span>field: numpy.ndarray[typing.Any, numpy.dtype[numpy.complex128 | numpy.float64]], plot_type: str) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>gets the given plot type of the field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_plot_type(
    field: npt.NDArray[np.complex_ | np.float_], plot_type: str
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    gets the given plot type of the field
    &#34;&#34;&#34;
    logger.info(f&#34;plotting type: &#39;{plot_type}&#39;&#34;)
    plot_dict = {
        &#34;abs&#34;: np.abs(field),
        &#34;imag&#34;: field.imag,
        &#34;real&#34;: field.real,
        &#34;sum&#34;: field.real + field.imag,
    }
    return plot_dict[plot_type]</code></pre>
</details>
</dd>
<dt id="sleplet.utils.plot_methods.find_max_amplitude"><code class="name flex">
<span>def <span class="ident">find_max_amplitude</span></span>(<span>function: <a title="sleplet.functions.coefficients.Coefficients" href="../functions/coefficients.html#sleplet.functions.coefficients.Coefficients">Coefficients</a>, *, plot_type: str = 'real', upsample: bool = True) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>for a given set of coefficients it finds the largest absolute value for a
given plot type such that plots can have the same scale as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_max_amplitude(
    function: Coefficients, *, plot_type: str = &#34;real&#34;, upsample: bool = True
) -&gt; float:
    &#34;&#34;&#34;
    for a given set of coefficients it finds the largest absolute value for a
    given plot type such that plots can have the same scale as the input
    &#34;&#34;&#34;
    # compute inverse transform
    if hasattr(function, &#34;slepian&#34;):
        field = slepian_inverse(function.coefficients, function.L, function.slepian)
    else:
        field = ssht.inverse(function.coefficients, function.L, Method=SAMPLING_SCHEME)

    # find resolution of final plot for boosting if necessary
    resolution = calc_plot_resolution(function.L) if upsample else function.L

    # boost field to match final plot
    boosted_field = boost_field(
        field,
        function.L,
        resolution,
        reality=function.reality,
        spin=function.spin,
        upsample=upsample,
    )

    # find maximum absolute value for given plot type
    return np.abs(create_plot_type(boosted_field, plot_type)).max()</code></pre>
</details>
</dd>
<dt id="sleplet.utils.plot_methods.normalise_function"><code class="name flex">
<span>def <span class="ident">normalise_function</span></span>(<span>f: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], *, normalise: bool) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>normalise function between 0 and 1 for visualisation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalise_function(
    f: npt.NDArray[np.float_], *, normalise: bool
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    normalise function between 0 and 1 for visualisation
    &#34;&#34;&#34;
    if not normalise:
        return f
    elif (f == 0).all():
        # if all 0, set to 0
        return f + 0.5
    elif np.allclose(f, f.max()):
        # if all non-zero, set to 1
        return f / f.max()
    else:
        # scale from [0, 1]
        return (f - f.min()) / f.ptp()</code></pre>
</details>
</dd>
<dt id="sleplet.utils.plot_methods.save_plot"><code class="name flex">
<span>def <span class="ident">save_plot</span></span>(<span>path: pathlib.Path, name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>helper method to save plots</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_plot(path: Path, name: str) -&gt; None:
    &#34;&#34;&#34;
    helper method to save plots
    &#34;&#34;&#34;
    plt.tight_layout()
    if settings[&#34;SAVE_FIG&#34;]:
        for file_type in {&#34;png&#34;, &#34;pdf&#34;}:
            logger.info(f&#34;saving {file_type}&#34;)
            filename = path / file_type / f&#34;{name}.{file_type}&#34;
            plt.savefig(filename, bbox_inches=&#34;tight&#34;)
    if settings[&#34;AUTO_OPEN&#34;]:
        plt.show()</code></pre>
</details>
</dd>
<dt id="sleplet.utils.plot_methods.set_outside_region_to_minimum"><code class="name flex">
<span>def <span class="ident">set_outside_region_to_minimum</span></span>(<span>f_plot: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], L: int, region: <a title="sleplet.utils.region.Region" href="region.html#sleplet.utils.region.Region">Region</a>) ‑> numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>for the Slepian region set the outisde area to negative infinity
hence it is clear we are only interested in the coloured region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_outside_region_to_minimum(
    f_plot: npt.NDArray[np.float_], L: int, region: Region
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;
    for the Slepian region set the outisde area to negative infinity
    hence it is clear we are only interested in the coloured region
    &#34;&#34;&#34;
    # create mask of interest
    mask = create_mask_region(L, region)

    # adapt for closed plot
    _, n_phi = ssht.sample_shape(L, Method=SAMPLING_SCHEME)
    closed_mask = np.insert(mask, n_phi, mask[:, 0], axis=1)

    # set values outside mask to negative infinity
    return np.where(closed_mask, f_plot, SPHERE_UNSEEN)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sleplet.utils" href="index.html">sleplet.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sleplet.utils.plot_methods.boost_field" href="#sleplet.utils.plot_methods.boost_field">boost_field</a></code></li>
<li><code><a title="sleplet.utils.plot_methods.calc_nearest_grid_point" href="#sleplet.utils.plot_methods.calc_nearest_grid_point">calc_nearest_grid_point</a></code></li>
<li><code><a title="sleplet.utils.plot_methods.calc_plot_resolution" href="#sleplet.utils.plot_methods.calc_plot_resolution">calc_plot_resolution</a></code></li>
<li><code><a title="sleplet.utils.plot_methods.convert_colourscale" href="#sleplet.utils.plot_methods.convert_colourscale">convert_colourscale</a></code></li>
<li><code><a title="sleplet.utils.plot_methods.create_plot_type" href="#sleplet.utils.plot_methods.create_plot_type">create_plot_type</a></code></li>
<li><code><a title="sleplet.utils.plot_methods.find_max_amplitude" href="#sleplet.utils.plot_methods.find_max_amplitude">find_max_amplitude</a></code></li>
<li><code><a title="sleplet.utils.plot_methods.normalise_function" href="#sleplet.utils.plot_methods.normalise_function">normalise_function</a></code></li>
<li><code><a title="sleplet.utils.plot_methods.save_plot" href="#sleplet.utils.plot_methods.save_plot">save_plot</a></code></li>
<li><code><a title="sleplet.utils.plot_methods.set_outside_region_to_minimum" href="#sleplet.utils.plot_methods.set_outside_region_to_minimum">set_outside_region_to_minimum</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>