<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sleplet.plot_methods API documentation</title>
<meta name="description" content="Methods to help in creating plots." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sleplet.plot_methods</code></h1>
</header>
<section id="section-intro">
<p>Methods to help in creating plots.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Methods to help in creating plots.&#34;&#34;&#34;
from pathlib import Path

import numpy as np
import pyssht as ssht
from matplotlib import colors
from matplotlib import pyplot as plt
from numpy import typing as npt

import sleplet
import sleplet._mask_methods
import sleplet._vars
import sleplet.functions.coefficients
import sleplet.harmonic_methods
import sleplet.meshes.mesh_coefficients
import sleplet.slepian.region
import sleplet.slepian_methods


def calc_plot_resolution(L: int) -&gt; int:
    &#34;&#34;&#34;TODO calculate appropriate resolution for given L.

    Args:
    ----
        L: _description_

    Returns:
    -------
        _description_
    &#34;&#34;&#34;
    res_dict = {1: 6, 2: 5, 3: 4, 7: 3, 9: 2, 10: 1}

    return next(
        (
            L * 2**exponent
            for log_bandlimit, exponent in res_dict.items()
            if 2**log_bandlimit &gt; L
        ),
        L,
    )


def _convert_colourscale(
    cmap: colors,
    *,
    pl_entries: int = 255,
) -&gt; list[tuple[float, str]]:
    &#34;&#34;&#34;Converts cmocean colourscale to a plotly colourscale.&#34;&#34;&#34;
    h = 1 / (pl_entries - 1)
    pl_colorscale = []

    for k in range(pl_entries):
        C = list(map(np.uint8, np.array(cmap(k * h)[:3]) * 255))
        pl_colorscale.append((k * h, f&#34;rgb{(C[0], C[1], C[2])}&#34;))

    return pl_colorscale


def _calc_nearest_grid_point(
    L: int,
    alpha_pi_fraction: float,
    beta_pi_fraction: float,
) -&gt; tuple[float, float]:
    &#34;&#34;&#34;Calculate nearest index of alpha/beta for translation
    this is due to calculating omega&#39; through the pixel
    values - the translation needs to be at the same position
    as the rotation such that the difference error is small.
    &#34;&#34;&#34;
    thetas, phis = ssht.sample_positions(L, Method=sleplet._vars.SAMPLING_SCHEME)
    pix_j = np.abs(phis - alpha_pi_fraction * np.pi).argmin()
    pix_i = np.abs(thetas - beta_pi_fraction * np.pi).argmin()
    alpha, beta = phis[pix_j], thetas[pix_i]
    sleplet.logger.info(f&#34;grid point: (alpha, beta)=({alpha:e}, {beta:e})&#34;)
    return alpha, beta


def save_plot(path: Path, name: str) -&gt; None:
    &#34;&#34;&#34;TODO helper method to save plots.

    Args:
    ----
        path: _description_
        name: _description_
    &#34;&#34;&#34;
    plt.tight_layout()
    for file_type in {&#34;png&#34;, &#34;pdf&#34;}:
        filename = path / file_type / f&#34;{name}.{file_type}&#34;
        sleplet.logger.info(f&#34;saving {filename}&#34;)
        plt.savefig(filename, bbox_inches=&#34;tight&#34;)
    plt.show(block=False)
    plt.pause(3)
    plt.close()


def find_max_amplitude(
    function: sleplet.functions.coefficients.Coefficients,
    *,
    plot_type: str = &#34;real&#34;,
    upsample: bool = True,
) -&gt; float:
    &#34;&#34;&#34;TODO for a given set of coefficients it finds the largest absolute value for a
    given plot type such that plots can have the same scale as the input.

    Args:
    ----
        function: _description_
        plot_type: _description_
        upsample: _description_

    Returns:
    -------
        _description_
    &#34;&#34;&#34;
    # compute inverse transform
    if hasattr(function, &#34;slepian&#34;):
        field = sleplet.slepian_methods.slepian_inverse(
            function.coefficients,
            function.L,
            function.slepian,
        )
    else:
        field = ssht.inverse(
            function.coefficients,
            function.L,
            Method=sleplet._vars.SAMPLING_SCHEME,
        )

    # find resolution of final plot for boosting if necessary
    resolution = calc_plot_resolution(function.L) if upsample else function.L

    # boost field to match final plot
    boosted_field = _boost_field(
        field,
        function.L,
        resolution,
        reality=function.reality,
        spin=function.spin,
        upsample=upsample,
    )

    # find maximum absolute value for given plot type
    return np.abs(_create_plot_type(boosted_field, plot_type)).max()


def _create_plot_type(
    field: npt.NDArray[np.complex_ | np.float_],
    plot_type: str,
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;Gets the given plot type of the field.&#34;&#34;&#34;
    sleplet.logger.info(f&#34;plotting type: &#39;{plot_type}&#39;&#34;)
    plot_dict = {
        &#34;abs&#34;: np.abs(field),
        &#34;imag&#34;: field.imag,
        &#34;real&#34;: field.real,
        &#34;sum&#34;: field.real + field.imag,
    }
    return plot_dict[plot_type]


def _set_outside_region_to_minimum(
    f_plot: npt.NDArray[np.float_],
    L: int,
    region: sleplet.slepian.region.Region,
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;For the Slepian region set the outisde area to negative infinity
    hence it is clear we are only interested in the coloured region.
    &#34;&#34;&#34;
    # create mask of interest
    mask = sleplet._mask_methods.create_mask_region(L, region)

    # adapt for closed plot
    _, n_phi = ssht.sample_shape(L, Method=sleplet._vars.SAMPLING_SCHEME)
    closed_mask = np.insert(mask, n_phi, mask[:, 0], axis=1)

    # set values outside mask to negative infinity
    return np.where(closed_mask, f_plot, sleplet._vars.SPHERE_UNSEEN)


def _normalise_function(
    f: npt.NDArray[np.float_],
    *,
    normalise: bool,
) -&gt; npt.NDArray[np.float_]:
    &#34;&#34;&#34;Normalise function between 0 and 1 for visualisation.&#34;&#34;&#34;
    if not normalise:
        return f
    if (f == 0).all():
        # if all 0, set to 0
        return f + 0.5
    # if all non-zero, set to 1 otherwise scale from [0, 1]
    return f / f.max() if np.allclose(f, f.max()) else (f - f.min()) / f.ptp()


def _boost_field(
    field: npt.NDArray[np.complex_ | np.float_],
    L: int,
    resolution: int,
    *,
    reality: bool,
    spin: int,
    upsample: bool,
) -&gt; npt.NDArray[np.complex_ | np.float_]:
    &#34;&#34;&#34;Inverts and then boosts the field before plotting.&#34;&#34;&#34;
    if not upsample:
        return field
    flm = ssht.forward(
        field,
        L,
        Reality=reality,
        Spin=spin,
        Method=sleplet._vars.SAMPLING_SCHEME,
    )
    return sleplet.harmonic_methods.invert_flm_boosted(
        flm,
        L,
        resolution,
        reality=reality,
        spin=spin,
    )


def compute_amplitude_for_noisy_mesh_plots(
    f: sleplet.meshes.mesh_coefficients.MeshCoefficients,
) -&gt; float | None:
    &#34;&#34;&#34;TODO for the noised mesh plots fix the amplitude to the initial data.

    Args:
    ----
        f: _description_

    Returns:
    -------
        _description_
    &#34;&#34;&#34;
    return (
        np.abs(_coefficients_to_field_mesh(f, f.unnoised_coefficients)).max()
        if f.unnoised_coefficients is not None
        else None
    )


def _coefficients_to_field_mesh(
    f: sleplet.meshes.mesh_coefficients.MeshCoefficients,
    coefficients: npt.NDArray[np.complex_ | np.float_],
) -&gt; npt.NDArray[np.complex_ | np.float_]:
    &#34;&#34;&#34;Computes the field over the whole mesh from the harmonic/Slepian coefficients.&#34;&#34;&#34;
    return (
        sleplet.slepian_methods.slepian_mesh_inverse(f.mesh_slepian, coefficients)
        if hasattr(f, &#34;mesh_slepian&#34;)
        else sleplet.harmonic_methods.mesh_inverse(f.mesh, coefficients)
    )


def compute_amplitude_for_noisy_sphere_plots(
    f: sleplet.functions.coefficients.Coefficients,
) -&gt; float | None:
    &#34;&#34;&#34;TODO for the noised sphere plots fix the amplitude to the initial data.

    Args:
    ----
        f: _description_

    Returns:
    -------
        _description_
    &#34;&#34;&#34;
    return (
        np.abs(_coefficients_to_field_sphere(f, f.unnoised_coefficients)).max()
        if f.unnoised_coefficients is not None
        else None
    )


def _coefficients_to_field_sphere(
    f: sleplet.functions.coefficients.Coefficients,
    coefficients: npt.NDArray[np.complex_ | np.float_],
) -&gt; npt.NDArray[np.complex_ | np.float_]:
    &#34;&#34;&#34;Computes the field over the samples from the harmonic/Slepian coefficients.&#34;&#34;&#34;
    return (
        sleplet.slepian_methods.slepian_inverse(coefficients, f.L, f.slepian)
        if hasattr(f, &#34;slepian&#34;)
        else ssht.inverse(
            coefficients,
            f.L,
            Reality=f.reality,
            Spin=f.spin,
            Method=sleplet._vars.SAMPLING_SCHEME,
        )
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sleplet.plot_methods.calc_plot_resolution"><code class="name flex">
<span>def <span class="ident">calc_plot_resolution</span></span>(<span>L: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>TODO calculate appropriate resolution for given L.</p>
<h2 id="args">Args:</h2>
<pre><code>L: _description_
</code></pre>
<h2 id="returns">Returns:</h2>
<pre><code>_description_
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_plot_resolution(L: int) -&gt; int:
    &#34;&#34;&#34;TODO calculate appropriate resolution for given L.

    Args:
    ----
        L: _description_

    Returns:
    -------
        _description_
    &#34;&#34;&#34;
    res_dict = {1: 6, 2: 5, 3: 4, 7: 3, 9: 2, 10: 1}

    return next(
        (
            L * 2**exponent
            for log_bandlimit, exponent in res_dict.items()
            if 2**log_bandlimit &gt; L
        ),
        L,
    )</code></pre>
</details>
</dd>
<dt id="sleplet.plot_methods.compute_amplitude_for_noisy_mesh_plots"><code class="name flex">
<span>def <span class="ident">compute_amplitude_for_noisy_mesh_plots</span></span>(<span>f: <a title="sleplet.meshes.mesh_coefficients.MeshCoefficients" href="meshes/mesh_coefficients.html#sleplet.meshes.mesh_coefficients.MeshCoefficients">MeshCoefficients</a>) ‑> float | None</span>
</code></dt>
<dd>
<div class="desc"><p>TODO for the noised mesh plots fix the amplitude to the initial data.</p>
<h2 id="args">Args:</h2>
<pre><code>f: _description_
</code></pre>
<h2 id="returns">Returns:</h2>
<pre><code>_description_
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_amplitude_for_noisy_mesh_plots(
    f: sleplet.meshes.mesh_coefficients.MeshCoefficients,
) -&gt; float | None:
    &#34;&#34;&#34;TODO for the noised mesh plots fix the amplitude to the initial data.

    Args:
    ----
        f: _description_

    Returns:
    -------
        _description_
    &#34;&#34;&#34;
    return (
        np.abs(_coefficients_to_field_mesh(f, f.unnoised_coefficients)).max()
        if f.unnoised_coefficients is not None
        else None
    )</code></pre>
</details>
</dd>
<dt id="sleplet.plot_methods.compute_amplitude_for_noisy_sphere_plots"><code class="name flex">
<span>def <span class="ident">compute_amplitude_for_noisy_sphere_plots</span></span>(<span>f: <a title="sleplet.functions.coefficients.Coefficients" href="functions/coefficients.html#sleplet.functions.coefficients.Coefficients">Coefficients</a>) ‑> float | None</span>
</code></dt>
<dd>
<div class="desc"><p>TODO for the noised sphere plots fix the amplitude to the initial data.</p>
<h2 id="args">Args:</h2>
<pre><code>f: _description_
</code></pre>
<h2 id="returns">Returns:</h2>
<pre><code>_description_
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_amplitude_for_noisy_sphere_plots(
    f: sleplet.functions.coefficients.Coefficients,
) -&gt; float | None:
    &#34;&#34;&#34;TODO for the noised sphere plots fix the amplitude to the initial data.

    Args:
    ----
        f: _description_

    Returns:
    -------
        _description_
    &#34;&#34;&#34;
    return (
        np.abs(_coefficients_to_field_sphere(f, f.unnoised_coefficients)).max()
        if f.unnoised_coefficients is not None
        else None
    )</code></pre>
</details>
</dd>
<dt id="sleplet.plot_methods.find_max_amplitude"><code class="name flex">
<span>def <span class="ident">find_max_amplitude</span></span>(<span>function: <a title="sleplet.functions.coefficients.Coefficients" href="functions/coefficients.html#sleplet.functions.coefficients.Coefficients">Coefficients</a>, *, plot_type: str = 'real', upsample: bool = True) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>TODO for a given set of coefficients it finds the largest absolute value for a
given plot type such that plots can have the same scale as the input.</p>
<h2 id="args">Args:</h2>
<pre><code>function: _description_
plot_type: _description_
upsample: _description_
</code></pre>
<h2 id="returns">Returns:</h2>
<pre><code>_description_
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_max_amplitude(
    function: sleplet.functions.coefficients.Coefficients,
    *,
    plot_type: str = &#34;real&#34;,
    upsample: bool = True,
) -&gt; float:
    &#34;&#34;&#34;TODO for a given set of coefficients it finds the largest absolute value for a
    given plot type such that plots can have the same scale as the input.

    Args:
    ----
        function: _description_
        plot_type: _description_
        upsample: _description_

    Returns:
    -------
        _description_
    &#34;&#34;&#34;
    # compute inverse transform
    if hasattr(function, &#34;slepian&#34;):
        field = sleplet.slepian_methods.slepian_inverse(
            function.coefficients,
            function.L,
            function.slepian,
        )
    else:
        field = ssht.inverse(
            function.coefficients,
            function.L,
            Method=sleplet._vars.SAMPLING_SCHEME,
        )

    # find resolution of final plot for boosting if necessary
    resolution = calc_plot_resolution(function.L) if upsample else function.L

    # boost field to match final plot
    boosted_field = _boost_field(
        field,
        function.L,
        resolution,
        reality=function.reality,
        spin=function.spin,
        upsample=upsample,
    )

    # find maximum absolute value for given plot type
    return np.abs(_create_plot_type(boosted_field, plot_type)).max()</code></pre>
</details>
</dd>
<dt id="sleplet.plot_methods.save_plot"><code class="name flex">
<span>def <span class="ident">save_plot</span></span>(<span>path: pathlib.Path, name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>TODO helper method to save plots.</p>
<h2 id="args">Args:</h2>
<pre><code>path: _description_
name: _description_
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_plot(path: Path, name: str) -&gt; None:
    &#34;&#34;&#34;TODO helper method to save plots.

    Args:
    ----
        path: _description_
        name: _description_
    &#34;&#34;&#34;
    plt.tight_layout()
    for file_type in {&#34;png&#34;, &#34;pdf&#34;}:
        filename = path / file_type / f&#34;{name}.{file_type}&#34;
        sleplet.logger.info(f&#34;saving {filename}&#34;)
        plt.savefig(filename, bbox_inches=&#34;tight&#34;)
    plt.show(block=False)
    plt.pause(3)
    plt.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sleplet" href="index.html">sleplet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sleplet.plot_methods.calc_plot_resolution" href="#sleplet.plot_methods.calc_plot_resolution">calc_plot_resolution</a></code></li>
<li><code><a title="sleplet.plot_methods.compute_amplitude_for_noisy_mesh_plots" href="#sleplet.plot_methods.compute_amplitude_for_noisy_mesh_plots">compute_amplitude_for_noisy_mesh_plots</a></code></li>
<li><code><a title="sleplet.plot_methods.compute_amplitude_for_noisy_sphere_plots" href="#sleplet.plot_methods.compute_amplitude_for_noisy_sphere_plots">compute_amplitude_for_noisy_sphere_plots</a></code></li>
<li><code><a title="sleplet.plot_methods.find_max_amplitude" href="#sleplet.plot_methods.find_max_amplitude">find_max_amplitude</a></code></li>
<li><code><a title="sleplet.plot_methods.save_plot" href="#sleplet.plot_methods.save_plot">save_plot</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>