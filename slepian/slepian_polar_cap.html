<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sleplet.slepian.slepian_polar_cap API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sleplet.slepian.slepian_polar_cap</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from concurrent.futures import ThreadPoolExecutor
from dataclasses import KW_ONLY
from pathlib import Path

import gmpy2 as gp
import numpy as np
import pyssht as ssht
from numpy import linalg as LA  # noqa: N812
from numpy import typing as npt
from pydantic import validator
from pydantic.dataclasses import dataclass

import sleplet
import sleplet._data.setup_pooch
import sleplet._mask_methods
import sleplet._parallel_methods
import sleplet._validation
import sleplet.harmonic_methods
import sleplet.slepian.region
from sleplet.slepian.slepian_functions import SlepianFunctions

_data_path = Path(__file__).resolve().parents[1] / &#34;_data&#34;

L_SAVE_ALL = 16


@dataclass(config=sleplet._validation.Validation)
class SlepianPolarCap(SlepianFunctions):
    &#34;&#34;&#34;class to create a polar cap Slepian region on the sphere.&#34;&#34;&#34;

    theta_max: float
    &#34;&#34;&#34;TODO&#34;&#34;&#34;
    _: KW_ONLY
    gap: bool = False
    &#34;&#34;&#34;TODO&#34;&#34;&#34;
    order: int | npt.NDArray[np.int_] | None = None
    &#34;&#34;&#34;TODO&#34;&#34;&#34;

    def __post_init_post_parse__(self) -&gt; None:
        super().__post_init_post_parse__()

    def _create_fn_name(self) -&gt; str:
        return f&#34;slepian_{self.region.name_ending}&#34;

    def _create_region(self) -&gt; &#34;sleplet.slepian.region.Region&#34;:
        return sleplet.slepian.region.Region(gap=self.gap, theta_max=self.theta_max)

    def _create_mask(self) -&gt; npt.NDArray[np.float_]:
        return sleplet._mask_methods.create_mask_region(self.L, self.region)

    def _calculate_area(self) -&gt; float:
        return 2 * np.pi * (1 - np.cos(self.theta_max))

    def _create_matrix_location(self) -&gt; str:
        return f&#34;slepian_eigensolutions_D_{self.region.name_ending}_L{self.L}_N{self.N}&#34;

    def _solve_eigenproblem(
        self,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        eval_loc = f&#34;{self.matrix_location}_eigenvalues.npy&#34;
        evec_loc = f&#34;{self.matrix_location}_eigenvectors.npy&#34;
        order_loc = f&#34;{self.matrix_location}_orders.npy&#34;
        try:
            return self._solve_eigenproblem_from_files(eval_loc, evec_loc, order_loc)
        except TypeError:
            return self._solve_eigenproblem_from_scratch(eval_loc, evec_loc, order_loc)

    def _solve_eigenproblem_from_files(
        self,
        eval_loc: str,
        evec_loc: str,
        order_loc: str,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        &#34;&#34;&#34;solves eigenproblem with files already saved.&#34;&#34;&#34;
        eigenvalues = np.load(
            sleplet._data.setup_pooch.find_on_pooch_then_local(eval_loc),
        )
        eigenvectors = np.load(
            sleplet._data.setup_pooch.find_on_pooch_then_local(evec_loc),
        )
        orders = np.load(sleplet._data.setup_pooch.find_on_pooch_then_local(order_loc))

        if self.order is not None:
            idx = np.where(orders == self.order)
            return eigenvalues[idx], eigenvectors[idx]
        self.order = orders
        return eigenvalues, eigenvectors

    def _solve_eigenproblem_from_scratch(
        self,
        eval_loc: str,
        evec_loc: str,
        order_loc: str,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        &#34;&#34;&#34;sovles eigenproblem from scratch and then saves the files.&#34;&#34;&#34;
        if isinstance(self.order, int):
            return self._solve_eigenproblem_order(self.order)

        evals_all = np.empty(0)
        evecs_all = np.empty((0, self.L**2), dtype=np.complex_)
        emm = np.empty(0, dtype=int)
        for m in range(-(self.L - 1), self.L):
            evals_m, evecs_m = self._solve_eigenproblem_order(m)
            evals_all = np.append(evals_all, evals_m)
            evecs_all = np.concatenate((evecs_all, evecs_m))
            emm = np.append(emm, [m] * len(evals_m))
        (
            eigenvalues,
            eigenvectors,
            self.order,
        ) = self._sort_all_evals_and_evecs(evals_all, evecs_all, emm)
        limit = self.N if self.L &gt; L_SAVE_ALL else None
        np.save(_data_path / eval_loc, eigenvalues)
        np.save(_data_path / evec_loc, eigenvectors[:limit])
        np.save(_data_path / order_loc, self.order)
        return eigenvalues, eigenvectors

    def _solve_eigenproblem_order(
        self,
        m: int,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        &#34;&#34;&#34;solves the eigenproblem for a given order &#39;m;&#34;&#34;&#34;
        emm = sleplet.harmonic_methods._create_emm_vector(self.L)
        Dm = self._create_Dm_matrix(abs(m), emm)
        eigenvalues, gl = LA.eigh(Dm)
        eigenvalues, eigenvectors = self._clean_evals_and_evecs(eigenvalues, gl, emm, m)
        return eigenvalues, eigenvectors

    def _sort_all_evals_and_evecs(
        self,
        eigenvalues: npt.NDArray[np.float_],
        eigenvectors: npt.NDArray[np.complex_],
        orders: npt.NDArray[np.int_],
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_], npt.NDArray[np.int_]]:
        &#34;&#34;&#34;sorts all eigenvalues and eigenvectors for all orders.&#34;&#34;&#34;
        idx = eigenvalues.argsort()[::-1]
        eigenvalues = eigenvalues[idx]
        eigenvectors = eigenvectors[idx]
        orders = orders[idx]
        return eigenvalues, eigenvectors, orders

    def _create_Dm_matrix(  # noqa: N802
        self,
        m: int,
        emm: npt.NDArray[np.float_],
    ) -&gt; npt.NDArray[np.float_]:
        &#34;&#34;&#34;Syntax:
        Dm = _create_Dm_matrix(m, P).

        Input:
        m  =  order
        P(:,1)  =  Pl = Legendre Polynomials column vector for l = 0 : L-1
        P(:,2)  =  ell values vector

        Output:
        Dm = (L - m) square Slepian matrix for order m

        Description:
        This piece of code computes the Slepian matrix, Dm, for order m and all
        degrees, using the formulation given in &#34;Spatiospectral Concentration on
        a Sphere&#34; by F.J. Simons, F.A. Dahlen and M.A. Wieczorek.
        &#34;&#34;&#34;
        Pl, ell = self._create_legendre_polynomials_table(emm)
        Dm = np.zeros((self.L - m, self.L - m))
        lvec = np.arange(m, self.L)

        Dm_ext, shm_ext = sleplet._parallel_methods.create_shared_memory_array(Dm)

        def func(chunk: list[int]) -&gt; None:
            &#34;&#34;&#34;calculate D matrix components for each chunk.&#34;&#34;&#34;
            Dm_int, shm_int = sleplet._parallel_methods.attach_to_shared_memory_block(
                Dm,
                shm_ext,
            )

            # deal with chunk
            for i in chunk:
                sleplet.logger.info(f&#34;start ell: {i}&#34;)
                self._dm_matrix_helper(Dm_int, i, m, lvec, Pl, ell)
                sleplet.logger.info(f&#34;finish ell: {i}&#34;)

            sleplet._parallel_methods.free_shared_memory(shm_int)

        # split up L range to maximise effiency
        chunks = sleplet._parallel_methods.split_arr_into_chunks(
            self.L - m,
            sleplet.NCPU,
        )

        # initialise pool and apply function
        with ThreadPoolExecutor(max_workers=sleplet.NCPU) as e:
            e.map(func, chunks)

        # retrieve from parallel function
        Dm = Dm_ext * (-1) ** m / 2

        # Free and release the shared memory block at the very end
        sleplet._parallel_methods.free_shared_memory(shm_ext)
        sleplet._parallel_methods.release_shared_memory(shm_ext)
        return Dm

    def _create_legendre_polynomials_table(
        self,
        emm: npt.NDArray[np.float_],
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.int_]]:
        &#34;&#34;&#34;create Legendre polynomials table for matrix calculation.&#34;&#34;&#34;
        Plm = ssht.create_ylm(self.theta_max, 0, 2 * self.L).real.reshape(-1)
        ind = emm == 0
        ell = np.arange(2 * self.L)[np.newaxis]
        Pl = np.sqrt((4 * np.pi) / (2 * ell + 1)) * Plm[ind]
        return Pl, ell

    def _dm_matrix_helper(  # noqa: PLR0913
        self,
        Dm: npt.NDArray[np.float_],
        i: int,
        m: int,
        lvec: npt.NDArray[np.int_],
        Pl: npt.NDArray[np.float_],
        ell: npt.NDArray[np.int_],
    ) -&gt; None:
        &#34;&#34;&#34;used in both serial and parallel calculations.&#34;&#34;&#34;
        el = int(lvec[i])
        for j in range(i, self.L - m):
            p = int(lvec[j])
            c = 0
            for n in range(abs(el - p), el + p + 1):
                A = Pl[ell == n - 1] if n != 0 else 1
                c += (
                    self._wigner3j(el, n, p, 0, 0, 0)
                    * self._wigner3j(el, n, p, m, 0, -m)
                    * (A - Pl[ell == n + 1])
                )
            Dm[i, j] = (
                self._polar_gap_modification(el, p)
                * np.sqrt((2 * el + 1) * (2 * p + 1))
                * c
            )
            Dm[j, i] = Dm[i, j]

    @staticmethod
    def _wigner3j(  # noqa: PLR0913
        l1: int,
        l2: int,
        l3: int,
        m1: int,
        m2: int,
        m3: int,
    ) -&gt; float:
        &#34;&#34;&#34;Syntax:
        s = _wigner3j (l1, l2, l3, m1, m2, m3).

        Input:
        l1  =  first degree in Wigner 3j symbol
        l2  =  second degree in Wigner 3j symbol
        l3  =  third degree in Wigner 3j symbol
        m1  =  first order in Wigner 3j symbol
        m2  =  second order in Wigner 3j symbol
        m3  =  third order in Wigner 3j symbol

        Output:
        s  =  Wigner 3j symbol for l1,m1; l2,m2; l3,m3

        Description:
        Computes Wigner 3j symbol using Racah formula
        &#34;&#34;&#34;
        if (
            2 * l1 != np.floor(2 * l1)
            or 2 * l2 != np.floor(2 * l2)
            or 2 * l3 != np.floor(2 * l3)
            or 2 * m1 != np.floor(2 * m1)
            or 2 * m2 != np.floor(2 * m2)
            or 2 * m3 != np.floor(2 * m3)
        ):
            raise ValueError(&#34;Arguments must either be integer or half-integer!&#34;)

        if (
            m1 + m2 + m3 != 0
            or l3 &lt; abs(l1 - l2)
            or l3 &gt; (l1 + l2)
            or abs(m1) &gt; abs(l1)
            or abs(m2) &gt; abs(l2)
            or abs(m3) &gt; abs(l3)
            or l1 + l2 + l3 != np.floor(l1 + l2 + l3)
        ):
            s = 0
        else:
            t1 = l2 - l3 - m1
            t2 = l1 - l3 + m2
            t3 = l1 + l2 - l3
            t4 = l1 - m1
            t5 = l2 + m2

            tmin = max(0, max(t1, t2))
            tmax = min(t3, min(t4, t5))

            # sum is over all those t for which the
            # following factorials have non-zero arguments
            s = sum(
                (-1) ** t
                / (
                    gp.factorial(t)
                    * gp.factorial(t - t1)
                    * gp.factorial(t - t2)
                    * gp.factorial(t3 - t)
                    * gp.factorial(t4 - t)
                    * gp.factorial(t5 - t)
                )
                for t in range(tmin, tmax + 1)
            )
            triangle_coefficient = (
                gp.factorial(t3)
                * gp.factorial(l1 - l2 + l3)
                * gp.factorial(-l1 + l2 + l3)
                / gp.factorial(l1 + l2 + l3 + 1)
            )

            s *= (
                np.float_power(-1, l1 - l2 - m3)
                * gp.sqrt(triangle_coefficient)
                * gp.sqrt(
                    gp.factorial(l1 + m1)
                    * gp.factorial(t4)
                    * gp.factorial(t5)
                    * gp.factorial(l2 - m2)
                    * gp.factorial(l3 + m3)
                    * gp.factorial(l3 - m3),
                )
            )
        return s

    def _polar_gap_modification(self, ell1: int, ell2: int) -&gt; int:
        &#34;&#34;&#34;eq 67 - Spherical Slepian functions and the polar gap in geodesy
        multiply by 1 + (-1)*(ell+ell&#39;).
        &#34;&#34;&#34;
        return 1 + self.gap * (-1) ** (ell1 + ell2)

    def _clean_evals_and_evecs(
        self,
        eigenvalues: npt.NDArray[np.float_],
        gl: npt.NDArray[np.float_],
        emm: npt.NDArray[np.float_],
        m: int,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        &#34;&#34;&#34;need eigenvalues and eigenvectors to be in a certain format.&#34;&#34;&#34;
        # Sort eigenvalues and eigenvectors in descending order of eigenvalues
        idx = eigenvalues.argsort()[::-1]
        eigenvalues = eigenvalues[idx]
        gl = gl[:, idx].conj()

        # put back in full D space for harmonic transform
        emm = emm[: self.L**2]
        ind = np.tile(emm == m, (self.L - abs(m), 1))
        eigenvectors = np.zeros((self.L - abs(m), self.L**2), dtype=np.complex_)
        eigenvectors[ind] = gl.T.flatten()

        # ensure first element of each eigenvector is positive
        eigenvectors *= np.where(eigenvectors[:, 0] &lt; 0, -1, 1)[:, np.newaxis]

        # if -ve &#39;m&#39; find orthogonal eigenvectors to +ve &#39;m&#39; eigenvectors
        if m &lt; 0:
            eigenvectors *= 1j

        return eigenvalues, eigenvectors

    @validator(&#34;order&#34;)
    def _check_order(cls, v, values):
        if v is not None and (np.abs(v) &gt;= values[&#34;L&#34;]).any():
            raise ValueError(f&#34;Order magnitude should be less than {values[&#39;L&#39;]}&#34;)
        return v

    @validator(&#34;theta_max&#34;)
    def _check_theta_max(cls, v):
        if v == 0:
            raise ValueError(&#34;theta_max cannot be zero&#34;)
        return v</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sleplet.slepian.slepian_polar_cap.SlepianPolarCap"><code class="flex name class">
<span>class <span class="ident">SlepianPolarCap</span></span>
<span>(</span><span>L: int, theta_max: float, *, gap: bool = False, order: int | numpy.ndarray[typing.Any, numpy.dtype[numpy.int64]] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>class to create a polar cap Slepian region on the sphere.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(config=sleplet._validation.Validation)
class SlepianPolarCap(SlepianFunctions):
    &#34;&#34;&#34;class to create a polar cap Slepian region on the sphere.&#34;&#34;&#34;

    theta_max: float
    &#34;&#34;&#34;TODO&#34;&#34;&#34;
    _: KW_ONLY
    gap: bool = False
    &#34;&#34;&#34;TODO&#34;&#34;&#34;
    order: int | npt.NDArray[np.int_] | None = None
    &#34;&#34;&#34;TODO&#34;&#34;&#34;

    def __post_init_post_parse__(self) -&gt; None:
        super().__post_init_post_parse__()

    def _create_fn_name(self) -&gt; str:
        return f&#34;slepian_{self.region.name_ending}&#34;

    def _create_region(self) -&gt; &#34;sleplet.slepian.region.Region&#34;:
        return sleplet.slepian.region.Region(gap=self.gap, theta_max=self.theta_max)

    def _create_mask(self) -&gt; npt.NDArray[np.float_]:
        return sleplet._mask_methods.create_mask_region(self.L, self.region)

    def _calculate_area(self) -&gt; float:
        return 2 * np.pi * (1 - np.cos(self.theta_max))

    def _create_matrix_location(self) -&gt; str:
        return f&#34;slepian_eigensolutions_D_{self.region.name_ending}_L{self.L}_N{self.N}&#34;

    def _solve_eigenproblem(
        self,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        eval_loc = f&#34;{self.matrix_location}_eigenvalues.npy&#34;
        evec_loc = f&#34;{self.matrix_location}_eigenvectors.npy&#34;
        order_loc = f&#34;{self.matrix_location}_orders.npy&#34;
        try:
            return self._solve_eigenproblem_from_files(eval_loc, evec_loc, order_loc)
        except TypeError:
            return self._solve_eigenproblem_from_scratch(eval_loc, evec_loc, order_loc)

    def _solve_eigenproblem_from_files(
        self,
        eval_loc: str,
        evec_loc: str,
        order_loc: str,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        &#34;&#34;&#34;solves eigenproblem with files already saved.&#34;&#34;&#34;
        eigenvalues = np.load(
            sleplet._data.setup_pooch.find_on_pooch_then_local(eval_loc),
        )
        eigenvectors = np.load(
            sleplet._data.setup_pooch.find_on_pooch_then_local(evec_loc),
        )
        orders = np.load(sleplet._data.setup_pooch.find_on_pooch_then_local(order_loc))

        if self.order is not None:
            idx = np.where(orders == self.order)
            return eigenvalues[idx], eigenvectors[idx]
        self.order = orders
        return eigenvalues, eigenvectors

    def _solve_eigenproblem_from_scratch(
        self,
        eval_loc: str,
        evec_loc: str,
        order_loc: str,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        &#34;&#34;&#34;sovles eigenproblem from scratch and then saves the files.&#34;&#34;&#34;
        if isinstance(self.order, int):
            return self._solve_eigenproblem_order(self.order)

        evals_all = np.empty(0)
        evecs_all = np.empty((0, self.L**2), dtype=np.complex_)
        emm = np.empty(0, dtype=int)
        for m in range(-(self.L - 1), self.L):
            evals_m, evecs_m = self._solve_eigenproblem_order(m)
            evals_all = np.append(evals_all, evals_m)
            evecs_all = np.concatenate((evecs_all, evecs_m))
            emm = np.append(emm, [m] * len(evals_m))
        (
            eigenvalues,
            eigenvectors,
            self.order,
        ) = self._sort_all_evals_and_evecs(evals_all, evecs_all, emm)
        limit = self.N if self.L &gt; L_SAVE_ALL else None
        np.save(_data_path / eval_loc, eigenvalues)
        np.save(_data_path / evec_loc, eigenvectors[:limit])
        np.save(_data_path / order_loc, self.order)
        return eigenvalues, eigenvectors

    def _solve_eigenproblem_order(
        self,
        m: int,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        &#34;&#34;&#34;solves the eigenproblem for a given order &#39;m;&#34;&#34;&#34;
        emm = sleplet.harmonic_methods._create_emm_vector(self.L)
        Dm = self._create_Dm_matrix(abs(m), emm)
        eigenvalues, gl = LA.eigh(Dm)
        eigenvalues, eigenvectors = self._clean_evals_and_evecs(eigenvalues, gl, emm, m)
        return eigenvalues, eigenvectors

    def _sort_all_evals_and_evecs(
        self,
        eigenvalues: npt.NDArray[np.float_],
        eigenvectors: npt.NDArray[np.complex_],
        orders: npt.NDArray[np.int_],
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_], npt.NDArray[np.int_]]:
        &#34;&#34;&#34;sorts all eigenvalues and eigenvectors for all orders.&#34;&#34;&#34;
        idx = eigenvalues.argsort()[::-1]
        eigenvalues = eigenvalues[idx]
        eigenvectors = eigenvectors[idx]
        orders = orders[idx]
        return eigenvalues, eigenvectors, orders

    def _create_Dm_matrix(  # noqa: N802
        self,
        m: int,
        emm: npt.NDArray[np.float_],
    ) -&gt; npt.NDArray[np.float_]:
        &#34;&#34;&#34;Syntax:
        Dm = _create_Dm_matrix(m, P).

        Input:
        m  =  order
        P(:,1)  =  Pl = Legendre Polynomials column vector for l = 0 : L-1
        P(:,2)  =  ell values vector

        Output:
        Dm = (L - m) square Slepian matrix for order m

        Description:
        This piece of code computes the Slepian matrix, Dm, for order m and all
        degrees, using the formulation given in &#34;Spatiospectral Concentration on
        a Sphere&#34; by F.J. Simons, F.A. Dahlen and M.A. Wieczorek.
        &#34;&#34;&#34;
        Pl, ell = self._create_legendre_polynomials_table(emm)
        Dm = np.zeros((self.L - m, self.L - m))
        lvec = np.arange(m, self.L)

        Dm_ext, shm_ext = sleplet._parallel_methods.create_shared_memory_array(Dm)

        def func(chunk: list[int]) -&gt; None:
            &#34;&#34;&#34;calculate D matrix components for each chunk.&#34;&#34;&#34;
            Dm_int, shm_int = sleplet._parallel_methods.attach_to_shared_memory_block(
                Dm,
                shm_ext,
            )

            # deal with chunk
            for i in chunk:
                sleplet.logger.info(f&#34;start ell: {i}&#34;)
                self._dm_matrix_helper(Dm_int, i, m, lvec, Pl, ell)
                sleplet.logger.info(f&#34;finish ell: {i}&#34;)

            sleplet._parallel_methods.free_shared_memory(shm_int)

        # split up L range to maximise effiency
        chunks = sleplet._parallel_methods.split_arr_into_chunks(
            self.L - m,
            sleplet.NCPU,
        )

        # initialise pool and apply function
        with ThreadPoolExecutor(max_workers=sleplet.NCPU) as e:
            e.map(func, chunks)

        # retrieve from parallel function
        Dm = Dm_ext * (-1) ** m / 2

        # Free and release the shared memory block at the very end
        sleplet._parallel_methods.free_shared_memory(shm_ext)
        sleplet._parallel_methods.release_shared_memory(shm_ext)
        return Dm

    def _create_legendre_polynomials_table(
        self,
        emm: npt.NDArray[np.float_],
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.int_]]:
        &#34;&#34;&#34;create Legendre polynomials table for matrix calculation.&#34;&#34;&#34;
        Plm = ssht.create_ylm(self.theta_max, 0, 2 * self.L).real.reshape(-1)
        ind = emm == 0
        ell = np.arange(2 * self.L)[np.newaxis]
        Pl = np.sqrt((4 * np.pi) / (2 * ell + 1)) * Plm[ind]
        return Pl, ell

    def _dm_matrix_helper(  # noqa: PLR0913
        self,
        Dm: npt.NDArray[np.float_],
        i: int,
        m: int,
        lvec: npt.NDArray[np.int_],
        Pl: npt.NDArray[np.float_],
        ell: npt.NDArray[np.int_],
    ) -&gt; None:
        &#34;&#34;&#34;used in both serial and parallel calculations.&#34;&#34;&#34;
        el = int(lvec[i])
        for j in range(i, self.L - m):
            p = int(lvec[j])
            c = 0
            for n in range(abs(el - p), el + p + 1):
                A = Pl[ell == n - 1] if n != 0 else 1
                c += (
                    self._wigner3j(el, n, p, 0, 0, 0)
                    * self._wigner3j(el, n, p, m, 0, -m)
                    * (A - Pl[ell == n + 1])
                )
            Dm[i, j] = (
                self._polar_gap_modification(el, p)
                * np.sqrt((2 * el + 1) * (2 * p + 1))
                * c
            )
            Dm[j, i] = Dm[i, j]

    @staticmethod
    def _wigner3j(  # noqa: PLR0913
        l1: int,
        l2: int,
        l3: int,
        m1: int,
        m2: int,
        m3: int,
    ) -&gt; float:
        &#34;&#34;&#34;Syntax:
        s = _wigner3j (l1, l2, l3, m1, m2, m3).

        Input:
        l1  =  first degree in Wigner 3j symbol
        l2  =  second degree in Wigner 3j symbol
        l3  =  third degree in Wigner 3j symbol
        m1  =  first order in Wigner 3j symbol
        m2  =  second order in Wigner 3j symbol
        m3  =  third order in Wigner 3j symbol

        Output:
        s  =  Wigner 3j symbol for l1,m1; l2,m2; l3,m3

        Description:
        Computes Wigner 3j symbol using Racah formula
        &#34;&#34;&#34;
        if (
            2 * l1 != np.floor(2 * l1)
            or 2 * l2 != np.floor(2 * l2)
            or 2 * l3 != np.floor(2 * l3)
            or 2 * m1 != np.floor(2 * m1)
            or 2 * m2 != np.floor(2 * m2)
            or 2 * m3 != np.floor(2 * m3)
        ):
            raise ValueError(&#34;Arguments must either be integer or half-integer!&#34;)

        if (
            m1 + m2 + m3 != 0
            or l3 &lt; abs(l1 - l2)
            or l3 &gt; (l1 + l2)
            or abs(m1) &gt; abs(l1)
            or abs(m2) &gt; abs(l2)
            or abs(m3) &gt; abs(l3)
            or l1 + l2 + l3 != np.floor(l1 + l2 + l3)
        ):
            s = 0
        else:
            t1 = l2 - l3 - m1
            t2 = l1 - l3 + m2
            t3 = l1 + l2 - l3
            t4 = l1 - m1
            t5 = l2 + m2

            tmin = max(0, max(t1, t2))
            tmax = min(t3, min(t4, t5))

            # sum is over all those t for which the
            # following factorials have non-zero arguments
            s = sum(
                (-1) ** t
                / (
                    gp.factorial(t)
                    * gp.factorial(t - t1)
                    * gp.factorial(t - t2)
                    * gp.factorial(t3 - t)
                    * gp.factorial(t4 - t)
                    * gp.factorial(t5 - t)
                )
                for t in range(tmin, tmax + 1)
            )
            triangle_coefficient = (
                gp.factorial(t3)
                * gp.factorial(l1 - l2 + l3)
                * gp.factorial(-l1 + l2 + l3)
                / gp.factorial(l1 + l2 + l3 + 1)
            )

            s *= (
                np.float_power(-1, l1 - l2 - m3)
                * gp.sqrt(triangle_coefficient)
                * gp.sqrt(
                    gp.factorial(l1 + m1)
                    * gp.factorial(t4)
                    * gp.factorial(t5)
                    * gp.factorial(l2 - m2)
                    * gp.factorial(l3 + m3)
                    * gp.factorial(l3 - m3),
                )
            )
        return s

    def _polar_gap_modification(self, ell1: int, ell2: int) -&gt; int:
        &#34;&#34;&#34;eq 67 - Spherical Slepian functions and the polar gap in geodesy
        multiply by 1 + (-1)*(ell+ell&#39;).
        &#34;&#34;&#34;
        return 1 + self.gap * (-1) ** (ell1 + ell2)

    def _clean_evals_and_evecs(
        self,
        eigenvalues: npt.NDArray[np.float_],
        gl: npt.NDArray[np.float_],
        emm: npt.NDArray[np.float_],
        m: int,
    ) -&gt; tuple[npt.NDArray[np.float_], npt.NDArray[np.complex_]]:
        &#34;&#34;&#34;need eigenvalues and eigenvectors to be in a certain format.&#34;&#34;&#34;
        # Sort eigenvalues and eigenvectors in descending order of eigenvalues
        idx = eigenvalues.argsort()[::-1]
        eigenvalues = eigenvalues[idx]
        gl = gl[:, idx].conj()

        # put back in full D space for harmonic transform
        emm = emm[: self.L**2]
        ind = np.tile(emm == m, (self.L - abs(m), 1))
        eigenvectors = np.zeros((self.L - abs(m), self.L**2), dtype=np.complex_)
        eigenvectors[ind] = gl.T.flatten()

        # ensure first element of each eigenvector is positive
        eigenvectors *= np.where(eigenvectors[:, 0] &lt; 0, -1, 1)[:, np.newaxis]

        # if -ve &#39;m&#39; find orthogonal eigenvectors to +ve &#39;m&#39; eigenvectors
        if m &lt; 0:
            eigenvectors *= 1j

        return eigenvalues, eigenvectors

    @validator(&#34;order&#34;)
    def _check_order(cls, v, values):
        if v is not None and (np.abs(v) &gt;= values[&#34;L&#34;]).any():
            raise ValueError(f&#34;Order magnitude should be less than {values[&#39;L&#39;]}&#34;)
        return v

    @validator(&#34;theta_max&#34;)
    def _check_theta_max(cls, v):
        if v == 0:
            raise ValueError(&#34;theta_max cannot be zero&#34;)
        return v</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sleplet.slepian.slepian_functions.SlepianFunctions" href="slepian_functions.html#sleplet.slepian.slepian_functions.SlepianFunctions">SlepianFunctions</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sleplet.slepian.slepian_polar_cap.SlepianPolarCap.gap"><code class="name">var <span class="ident">gap</span> : bool</code></dt>
<dd>
<div class="desc"><p>TODO</p></div>
</dd>
<dt id="sleplet.slepian.slepian_polar_cap.SlepianPolarCap.order"><code class="name">var <span class="ident">order</span> : int | numpy.ndarray[typing.Any, numpy.dtype[numpy.int64]] | None</code></dt>
<dd>
<div class="desc"><p>TODO</p></div>
</dd>
<dt id="sleplet.slepian.slepian_polar_cap.SlepianPolarCap.theta_max"><code class="name">var <span class="ident">theta_max</span> : float</code></dt>
<dd>
<div class="desc"><p>TODO</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sleplet.slepian.slepian_functions.SlepianFunctions" href="slepian_functions.html#sleplet.slepian.slepian_functions.SlepianFunctions">SlepianFunctions</a></b></code>:
<ul class="hlist">
<li><code><a title="sleplet.slepian.slepian_functions.SlepianFunctions.L" href="slepian_functions.html#sleplet.slepian.slepian_functions.SlepianFunctions.L">L</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sleplet.slepian" href="index.html">sleplet.slepian</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sleplet.slepian.slepian_polar_cap.SlepianPolarCap" href="#sleplet.slepian.slepian_polar_cap.SlepianPolarCap">SlepianPolarCap</a></code></h4>
<ul class="">
<li><code><a title="sleplet.slepian.slepian_polar_cap.SlepianPolarCap.gap" href="#sleplet.slepian.slepian_polar_cap.SlepianPolarCap.gap">gap</a></code></li>
<li><code><a title="sleplet.slepian.slepian_polar_cap.SlepianPolarCap.order" href="#sleplet.slepian.slepian_polar_cap.SlepianPolarCap.order">order</a></code></li>
<li><code><a title="sleplet.slepian.slepian_polar_cap.SlepianPolarCap.theta_max" href="#sleplet.slepian.slepian_polar_cap.SlepianPolarCap.theta_max">theta_max</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>